\section{Hardwareentwicklung, Softwarebackend \\ und Benutzeroberfläche \textcolor{gray}{(Benedikt Simbürger)}}

\subsection{Hardware}

\subsubsection{Planung - Grundanforderungen} 
Grundlegende Anforderungen zur Planung der AFSS-Mechanik sind Transportfähigkeit, eine möglichst einfache Realisierung mit HTL-Mitteln und möglichst wenige Kompromisse in der Funktion oder Zuverlässigkeit eingehen zu müssen.\\
Die Anforderung der Transportfähigkeit limitiert die Größe des Lagers auf 2.3 m Länge, um im Lift transportiert werden zu können, und auf 1.9 m Höhe aufgrund der Türhöhe im Keller. Weiters müssen auch noch Rollen an den Rahmen angebracht werden, um das Lager ohne großen Mehraufwand bewegen zu können. Diese Extrahöhe der Räder (ca. 80 mm) limitiert den Rahmen weiter.\\
Nun soll dieser rund 2.25 m lange und 1.8 m hohe Raum optimal genutzt werden, um eine möglichst große Lagerdichte sicherstellen zu können.\\
Um eine möglichst gute Erweiterbarkeit sowie eine Fertigung an der Schule zu ermöglichen, sollen für die mechanische Trägerkonstruktion sogenannte Item-Profile verwendet werden.


\begin{wrapfigure}{r}{0.3\textwidth}
    \vspace{0mm}
    \includegraphics[width=0.3\textwidth]{Item-Standartverbindungssatz.png}
    \centering
    \caption{Item Profil mit Standartverbindungssatz, Quelle: \cite{Item_svs}}
    \label{sfs_item}
\end{wrapfigure}
\paragraph{Item}\mbox{}\\
Das Item-Profilsystem ist ein System, welches Aluminium-Extrusionen in verschiedenen Ausführungen sowie viele Verbindungsmöglichkeiten zu sich selbst sowie anderen mechanischen Elementen bietet. Hierbei gibt es eine breite Auswahl an Profilen, von 20x20 mm bis 40x40 mm Querschnitt. Für alle Komponenten mit hoher mechanischer Beanspruchung werden 40x40-Extrusionen verbaut, da diese eine besonders hohe Biegefestigkeit aufweisen. Für Anwendungen mit geringerer Beanspruchung sowie aus Platz- und Gewichtsparmaßnahmen werden 20x20-Extrusionen verwendet.
Zur Verbindung zu anderen Bauelementen gibt es die Möglichkeit, sogenannte Nutensteine mit verschiedenen Gewinden in die Nut einzulegen und dort Platten o. Ä. anzuschrauben. Um Item-Profile untereinander zu verbinden, können Standardverbindungssätze wie in Abb. \ref{sfs_item} verwendet werden.\\

Die Anwendung im AFSS erfordert ausserdem recht lange Verfahrwege. Um dies kostengünstig umsetzen zu können, werden V-Slot-Profile verwendet.


\begin{wrapfigure}{R}{0.3\textwidth}
    \includegraphics[width=0.3\textwidth]{V-Wheel.jpg}
    \centering
    \caption{V-Slot-Profil mit V-Wheel, Quelle: \cite{v_slot_wheel}}
    \label{v-wheel}
\end{wrapfigure}
\paragraph{V-Slot}\mbox{}\\
Auch V-Slot-Profile sind Aluminium-Extrusionen. Diese können grundsätzlich auch ähnlich wie Item-Profile mit Nutensteinen etc. verwendet werden, sind aber zusätzlich darauf ausgelegt, dass ein V-Wheel in einer Narbe des Profils rollen kann (siehe Abb. \ref{v-wheel}). Diese Profile sind in einer C-Profil-Form erhältlich. Diese sind für die langen Verfahrwege optimal, da einerseits auch breitere und mehr V-Wheels verwendet werden können, sowie einen sehr großen Widerstandsmoment aufweisen.


\subsubsection{Vorgehensweise}
Aufgrund der besonderen und sehr komplexen Anforderungen dieser Mechanik erfolgt die Entwicklung in mehreren Iterationen. Nach Auslegung der Grundparameter wird eine Grundkonstruktion erstellt, um mögliche Lösungsansätze für die jeweiligen Komponenten zu skizzieren. Durch diese grobe Planung können viele Konzepte mit geringerem Zeitaufwand iteriert werden und auch mögliche Missverständnisse o. Ä. frühzeitig aufgeklärt und überarbeitet werden. Weiters werden bei diesem Prozess wichtige Fähigkeiten in der Bedienung der CAD-Software gewonnen und so die Geschwindigkeit der zukünftigen Designiterationen beschleunigt.\\
Um bestimmte Elemente der Mechanik einzeln zu testen, werden auch mehrere Prototypen gebaut und die gewonnenen Erkenntnisse in die finale Konstruktion miteingebunden.\\

\begin{figure}[H]
    \centering
    \begin{subfigure}{.3\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{pt_x.jpg}
        \caption{X-Achse}
        \label{pts:plt_x}
    \end{subfigure}%
    \begin{subfigure}{.3\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{pt_y.jpg}
        \caption{Y-Achse}
        \label{pts:plt_y}
    \end{subfigure}%
    \begin{subfigure}{.3\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{pt_lg.jpg}
        \caption{Lagerregal}
        \label{pts:plt_ls}
    \end{subfigure}
    \caption{Prototypen}
    \label{pts}
\end{figure}
\vspace{-3mm}

\paragraph{Rahmenbedingungen für die Fertigung}\mbox{}\\
Damit die Fertigung der Mechanik an der HTL-Mössingerstraße in einem realistischen Zeitrahmen möglich ist, müssen gewisse Rahmenbedingungen bei der Planung beachtet werden.
\begin{itemize}
    \item Für Verbindungen mit geringer bis mittlerer mechanischer Beanspruchung werden Bauteile so geplant, dass diese im Lasercutter gefertigt werden können, sowie in den Stärken, die der Werkstätte zur Verfügung stehen (3, 4 und 5 mm). Dabei muss beachtet werden, dass die Acrylplatten gegossen sind und dadurch recht hohe Toleranzen (bis zu +0.3 mm) aufweisen.
    \item Verbindungen zwischen Platten und Item- oder V-Slot-Profilen werden möglichst einheitlich gestaltet. Grundsätzlich gilt: Verbindungen mit Item-Baureihe (BR) 5 (20x20) werden grundsätzlich in M5 ausgeführt, außer bei Platzmangel in M3. Verbindungen mit BR 8 (40x40) werden in M8 ausgeführt.
    \item Bei Bauteilen mit hoher mechanischer Beanspruchung wird Aluminiumblech mit 5 mm Stärke verwendet. Dieses wird zwar CNC-gefräst, doch um bei der Fertigung Zeit zu sparen, wird davon abgesehen, Taschen o. Ä. einzuplanen. Stattdessen wird immer ein flaches Profil verwendet, welches sich mit 2.5D-Fräsverfahren mit Durchgangsfräsen, ähnlich einem Lasercutter, fertigen lässt. Bei Aluminiumteilen wird darauf geachtet, dass diese immer aus 5 mm dickem Aluminiumeloxal gefertigt werden.
\end{itemize}

%---corrigiert----


\paragraph{Konstruktionsvorgang}\mbox{}\\
Um ein so umfangreiches Projekt umsetzen zu können, muss auch bei der 3D-Planung möglichst viel Ordnung herrschen. Um möglichst effizient zu arbeiten, werden wiederverwendete Bauteile in einer eigens angelegten Bauteilbibliothek abgelegt. So können beispielsweise Aluminiumprofile in Normlängen, oder Sensoren, einfach die aktuelle Konstruktion eingefügt werden, ohne diese jedes mal neu zu Konstruieren. \\
Auch in einer Konstruktion selbst ist auf die übersicht zu achten. Zu diesem Zweck ist es sehr sinnvoll, zusammenhängende Objekte in Komponenten zusammenzufassen. Diese sind vergleichbar mit Ordnern. Wie auch Ordner können auch Komponenten ineinander Verschachtelt werden. So ist es möglich eine sauberes Struktur umzusetzen, welche es beispielsweise vereinfacht einzelne Konstruktionsteile zu betrachten, oder Änderungen an nur diesen durchzuführen.

\subsubsection{Rahmen}

Der Rahmen des AFSS bezeichnet jene Struktur, welche als äußerstes Gehäuse, sowie grundlegende mechanische Stabilität bietet. Es ist geplant, dass es die Anforderungen von Maximalhöhe und -länge optimal ausnutzt sowie breite minimal hält. \\
Umgesetzt wird dies mit einem Gerüst aus 40x40-Aluminium Extrusionen. Dieses hat weiters oben udn unten noch zwei Längsstreben, die dazu dienen, eine möglichst platzsparende Aufhängung, der X-Achsen V-Slot-Profile, zu realsisieren. Auf einer Seite wird weiters eine Aussparung eingeplant, um genug Freiraum übrig zu lassen, damit der Querförederer die Boxen reibungslos auf das Förderband bringen kann.\\
Weiters muss noch eingeplant wieder, dass noch Rollen zum Transport angebracht werden müssen. Dadurch, dass diese Auswirkungen auf die Maximalhöhe haben, muss dass in die Auslegung der Y-Achse einfließen, um Bewegung durch Türen zu ermöglichen.

\subsubsection{X-Achse}
Die X-Achse des AFSS ist das Mechanische Herzstück. Sie ist jene Achse, welche sich horizontal bewegt. Sie hat einen langen Verfahrweg und hohen mechanische Anforderungen (sie muss ihr Eigengewicht und das Gewicht der YZ-Achse stützen). 
Grundelement der X-Achse sind V-Slot C-Profile, welche oben und unten aufgehängt werden. Diese sind in 1.5 m Länge erhältlich, deshalb wird die ganze Achse darauf ausgelegt, 2 Stück also 3 m Schiene zu verwenden. Diese sind weiters mit 6 Nivelierungsschrauben pro V-Profil ausgestattet, um diese möglichst Parallel zueinander sowie in Waage zu positionieren.

\paragraph{Grundanforderungen}\mbox{}\\
Auf der X-Achse verläuft der X-Schlitten, dieser hat die Aufgabe die Y-Achse zu positionieren. Um dies zu bewerkstelligen, muss dieser alle nötigen Motoren und Sensoren beinhalten. Weiters muss er einen Angriffspunkt bieten, um diesen zu bewegen. Ausserdem soll der Schlitten horizontal und vertikal möglichst kompakt sein, um einen möglichst großen Verfahrweg in X- als auch Y- Richtung zu ermöglichen.

\paragraph{Antrieb}\mbox{}\\
Angetrieben wird die X-Achse mit zwei Schrittmotoren, welche jeweils an einer Schiene (oben und unten) angebracht werden. Diese treiben mithilfe eines Zahnriemen die zwei X-Schlitten an. Als Zahnriemen wurde aufgrund der hohen Kraftübertragung, sowie großer Länge auf ein AT5-Zahnprofil mit 16 mm Riemenbreite der Firma Mähdler gesetzt. Dieser wird vom Motor über eine Entsprechende Zahnscheibe angetrieben, und am Shuttle befestigt. Als Schrittmotor wird aus Einfachheitsgründen das selbe Modell wie bei der Y-Achse verwendet. Diese erzeigen auch genügend Moment um die X-Achse anzutreiben.

\paragraph{Riemenspannung X-Achse} \mbox{}\\
Da der Riemen für eine zuverlässige Kraftübertragung bei so langen Verfahrwegen eine relativ große Vorspannkraft benötigt wird, ist das Zahnriemenklemmelement auf der X-Achse auch dementsprechend auszuführen. Um den Zahnriemen zu greifen, muss ein Negativ in Aluminium gefräßt werden, in dieses der Zahnriemen dann auf beiden Seiten des Schlittens geklemmt wird. Die Aufhängung der einen Seite ist einfach mit den Item-Profilen verschraubt, lässt aber noch etwas platz, um den Riemen mit der Hand vorzuspannen. Auf der anderen Seite ist das Klembrett über zwei Gewindestangen mit dem restlichen Shuttle verbunden. Diese können festgezogen werden, um die nötigen Vorspannkräfte zu erzeugen. Ausserdem ist diese Spannvorrichtung in einem Formfaktor ausgeführt, welcher es erlaubt, dierekt darüber die Motoren der Y-Achse anzubringen. 

\paragraph{Achsenführung} \mbox{}\\
Die Führung der Achse im V-Slot-Profil wird mit V-Wheels durchgeführt. Sechs V-Wheels werden von oben auf das C-Profil gedrückt. Jedes Rad wird einzeln aufgehangen. Weiters ist überall eine Schraube mit welcher das Rad weiter in die Führung hienein gedrückt werden kann, sowie ein bis zwei Klemmpunkte, um bei Betrieb die Last von der Spannschraube nehmen zu können. Durch den geringen Platz im Schlitten ist es durchaus eine Herausforderung, dass all diese Mechanik, neben der Spannelemente und Motoren in einem so kleinen Shuttel platz finden. Auf der Seite des Schlittens werden noch weitere V-Wheels angebracht, welche die Spurführung übernehmen.
Im oberen Schlitten werden nur diese Führungsräder verbaut, da es nicht möglich und nötig ist, vertikale Kräfte zu unterstützen.

\paragraph{Kabelführung} \mbox{}\\
Um Sensoren und Aktoren der Y- und Z-Achse zu unterstützen, müssen dementsprechende Leitungen auf das X-Shuttel verlegt werden. Die wird mithilfe einer Kabelschleppkette der Firma Igus umgesetzt. Diese wird parallel zum unteren C-Profil verlegt und unter Berücksichtigung der Biegeradien am X-Shuttel befestigt. Bei dieser ist darauf zu achten, dass sie alle benötigten Leitungen, sowie genügend Freiraum für die Biegung einhält \cite{igus_freitragend}. Weiters müssen Signal- und Aktorstromkreise durch trennstege voneinander getrennt werden.\\
Um die weiteren Geräte am AFSS zu versorgen, müssen zusätzlich noch Verdrahtungskanäle am Rahmen angebracht werden. 

\paragraph{Sensoren}\mbox{}\\
Die Sensorik ist bei jeder Achse ähnlich aufgebaut. Immer zwei Endschalter und ein Referenzierschalter. Bei der X-Achse werden als Endschalter mechanische Rolltaster verwendet. Diese werden neben den V-Slot-Profilen befestigt und von einem, vom Schlitten abstrehenden Arm ausgelöst. 

\subsubsection{Y-Achse}
Als Y-Achse wird jene Achse bezeichnet, die ihre Bewegung vertikal durchführt. Sie hat die Aufgabe, die Z-Achse bzw. das YZ-Shuttel auf Position zu bringen. Wichtig hierbei ist jedoch, dass die Y-Achse die Aufgabe des aufheben der Box übernimmt.

\paragraph{Antriebsauslegung}\mbox{}\\
Dadurch, dass die Y-Achse sowohl YZ-Shuttle als auch die Boxen aufheben muss, muss der Antrieb dementsprechend dimensioniert werden. Als Formfaktor sol ein Nema23-Schrittmotor verwendet werden. Diese sind weit verbreitet und zu Servomotoren verhältnismäßig kostengünstig. Als grundformfaktor wird ein 2 Nm Motor gewählt, nun soll überprüft werden, ob dieser die Last der YZ-Achse auch antreiben kann.

\vspace{5mm}
\noindent\begin{minipage}{\textwidth}
\begin{minipage}[t]{0.5\textwidth}
    \begin{equation*}
        F = \frac{M}{\frac{d}{2} \cdot 1000} \cdot n
    \end{equation*}
    \begin{equation*}
        F = \frac{2 \unit{Nm}}{\frac{30 \unit{mm}}{2} \cdot 1000} \cdot 2 = 266 \unit{N}
    \end{equation*}
\end{minipage}%
\begin{minipage}[t]{0.4\textwidth}
    \vspace*{-5mm}
    \begin{align*}
        &F: \text{Antriebskraft der Y-Achse} & &\left[N\right]\\
        &M: \text{Drehmoment eines Motors} & &\left[Nm\right]\\
        &d: \text{Durchmesser der Antriebszahnscheibe} & &\left[mm\right]\\
        &n: \text{Anzahl der Antriebe} & &
    \end{align*}
\end{minipage}
\end{minipage}

\vspace{5mm}

Bei Konstruktion einer früheren Version des YZ-Shuttels wurde erfasst, dass das Shuttel bis zu 13 kg Wiegen kann. Dies wird zwar in einer späteren Iteration des Designvorgangs noch verbessert, dient jedoch als richtwert der Antriebsauslegung. 13 kg erzeugen ohne Berücksichtigung von Reibung knapp 130 N. Die Antriebskraft der Schrittmotoren reicht auf jeden fall aus. Doch diese Überdimensionierung ist unter dem Aspekt, dass die Antriebe über keine Bremse verfügen, also das gesamte Gewicht der Z-Achse und der Kabelschleppkette immer unterstützen müssen, durchaus sinnvoll.

\paragraph{Zahnriemen und Umlenkung}\mbox{}\\
Als Zahnriemen wird auch bei der Y-Achse auf eine AT5x16-Profil gesetzt. Doch hier gestaltet sich die Positionierung ebendieses nicht so simpel wie bei der X-Achse. Da der Zahnriemen beim YZ-Shuttle an einem bestimmten Punkt befestigt werden muss, muss er auch dort wieder rückgeführt werden. Die Umlenkung des Zahnriemens gestaltet sich jedoch wesentlich anspruchsvoller als bei der X-Achse, da einerseits ain möglichst kompakter Formfaktor angestrebt werden muss, sowie andererseits eine aufhängungstechnisch sehr unvorteilhafte Positionierung vor dem V-Slot C-profil erforderlich ist. Aus diesem Grund wir eine konstrukiton aus Aluminium, welche sich selbst verhakt konstruiert. Sie muss Seitlich ann den Profilen verschraubt werden. Im vorderen Überhang werden Aluminiumelemente eingehängt, welche die Aufhängung der Achse für die Umlenkung erlauben. 

\paragraph{Zahnriemenaufgängung}\mbox{}\\
Um die optimale Postiton der Zahnriemenaufhängung für die Y-Achse bestimmen zu können, wird überschlagsmäßig ein Massenschwerpunkt in Z-Richtung berechnet. Um die Konstrukiton beginnen zu können, werden hierfür ungefähre Werte angenommen.

\noindent\begin{minipage}{\textwidth}
\begin{minipage}[t]{0.5\textwidth}
    \vspace{7mm}
    \begin{equation*}
        X_s = \frac{1}{M} \cdot \displaystyle\sum_{i = 0}^{n} z_i \cdot m_i
    \end{equation*}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
    \begin{align*}
        &Z_s: \text{Z-Koordinate des Massenschwerpunkts} & &\left[m\right]\\
        &M: \text{Gesamtmasse} & &\left[kg\right]\\
        &z_1: \text{Z-Koordinate der Teilmasse} & &\left[m\right] \\
        &m_1: \text{Masse der Teilmasse} & &\left[kg\right]
    \end{align*}
\end{minipage}
\end{minipage}

\begin{table}[H]
    \centering
    \centering
        \begin{tabular}{c c c}
            Gegenstand & Masse in kg & Position in mm\\
            \hline
            Motor & 0.3 & 21 \\
            Z-Schiene & 1 & 150 \\
            Z-Gable & 0.3 & 180 
        \end{tabular}
    \caption{X-Achse unbeladen und eingefahren}
        \vspace{5mm}
        \centering
        \begin{tabular}{c c c}
            Gegenstand & Masse in kg & Position in mm\\ 
            \hline
            Motor & 0.3 & 21 \\
            Z-Schiene & 1 & 150 \\
            Z-Gabel & 1.3 & 380
        \end{tabular}
        \caption{X-Achse beim Ladevorgang}
\end{table}
So werden zwei Schwerpunkte errechnet: ca. 130 mm im unbeladen und 250 mm während dem Ladevorgang. Da die Stabilität des Y-Schuttels während dem Ladevorgang wichtiger ist als während einer Leerfahrt wird das Y-Shuttle so positioniert, dass die Aufhängung des Zahnriemen bei rund 200 mm liegt. \\
Weiters muss auch dieser Zahnriemen wieder gespannt werden, durch die geringere Zahnriemenlänge, wird auch der Spannmechanismus verkleinert.
Leider muss dieser aus Platzgründen ausserflucht zum Zahnriemen angebracht werden. Die Folgen dieser Auslenkung auf die Riemenspannung kann durch folgenden Ausdruck, die Länge die der Zahnriemen bei einer bestimmten Position braucht, um Spannungslos zu sein, approximiert werden.( Hierbei wird von einem linearen Zusammenhang zwischen Kraft auf die Aufhängung und Längenkontaktion ausgegangen, in der Realität würde jedoch die Elastizität des Zahnriemens als auch jene der Aufhängung Auswirkungen haben, aber diese verringern die Auswirkungen nur zu unseren Gunsten).
    
    \vspace{4mm}
    \noindent\begin{minipage}{\textwidth}
    \begin{minipage}[t]{0.5\textwidth}
        \begin{equation*}
            K(h) = \sqrt{h^2+d^2}+(l-h)
        \end{equation*}
        \begin{equation*}
            K(h) = \sqrt{h^2+28^2}+(1500-h)
        \end{equation*}
    \end{minipage}%
    \begin{minipage}[t]{0.5\textwidth}
        \vspace{-7mm}
        \begin{align*}
            &K(h): \text{theoretische Länge des Riemen} & &\left[mm\right]\\
            &h: \text{Position des Schlittens} & &\left[mm\right]\\
            &l: \text{Umlenkungsrollenabstand} & &\left[mm\right]\\
            &d: \text{Abstand der Klemme zur Flucht} & &\left[mm\right]
        \end{align*}
    \end{minipage}
    \end{minipage}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.7\textwidth]{Zahnrimenenversatz.png}
        \caption{Zahnriemenkontraktion grafisch dargestellt}
        \label{zahnriemenversatz}
    \end{figure}

Aus der Abbildung \ref{zahnriemenversatz} geht, wie schon intuitiv vermutet, hervor, dass ist diese Assymetrie nur dann ein Problem, wenn der Schlitten weit unten ist. Ein konkretes maß kann folgendermaßen erhalten werden: \(K(80) - (750) = 4.24 \unit{mm}\). Der unterschied in der benötigten Riemenlänge zwischen der Mittelstellung (750 mm) und Ruheposition (80 mm über der Zahnscheibe) ist also rund 4 mm. Im anbetracht dessen, dass dies Länge auf zwei Seiten (Hin- und Rücklaufseitig) des Zahnriemen aufgeteilt wird (welcher etwas elastisch ist), sowie etwas biegung in der Umlenkungsaufhängung auftritt, wird diese Extraspannung toleriert.

\paragraph{Shuttleführung}\mbox{}\\
Das YZ-Shuttel wird aus Stabilitätsgründen ebenfalls mit einem V-Slot C-Profil geführt. Dieses sind auf beiden Seiten jeweils oben und unten befestigt. Die Länge wird so gewählt, dass die Verwendung eines 1.5 m langen Profils perfekt ausreicht. Da dass YZ-Shuttel wesentlich weniger Kraft auf die Führung auswirkt können weniger Führungsräder verwendet werden. Die Hauptführungsräder werden so Positioniert,  dass sich ein Dreieck ergibt. Dieses dient dazu, dass sowohl beim Aufhebevorgang als auch beim Leerlauf immer eine Klemmung um die Führungsschiene entsteht. Hierbei sind jene V-Wheels, welche beim Aufhebevorgang belastet werden, doppelt ausgeführt. Wie schon bei der X-Achse sind auch hier wieder alle V-Wheel-abstände mit Schrauben einstellbar. Zusätzlich zur Hauptführung sind auch aussen jeweils noch zwei Führungsräder angebracht, um das Shuttel zusätzlich zu stabilisieren.

\paragraph{Sensoren}\mbox{}\\
Da die Endschalter der Y-Achse kapazitiv ausgeführt sind, muss auf dem Shuttel ein Metallisches Gegenstück angebracht sein. Diese stehen uben und unten über und lösen so vor Kolission aus. Um die Sensoren anzubinden muss auch ein ASi-Client auf dem X-Shuttel angebracht werden.

\paragraph{Kabelschleppkette}\mbox{}\\
Um Versorgugng der Z-Achse herstellen zu können, muss eine Kabelschleppkette vom X- zum Y-Shuttel angebracht werden. Ach diese muss leider sonderanforderungen erfüllen. Da die Versorgung von unten ausgeht, muss die Kabelschleppkette stehend eingebaut werden. Dies ist grundsätzlich eine äußerst ungünstige situation, da diese Schlepkette der beschleinugung des X-Shuttels ausgesetzt ist. Um ein Schwingen möglichst zu verhindern werden seitlich noch Führungselemente angebracht. Ausserdem sind die Anschlusellemente fest um die ersten Kettenglieder extra zu unterstützen. \cite{igus_vertikal}

\subsubsection{Z-Achse}
Als Z-Achse oder Gabel, wird jener Teil des AFSS bezeichnet, der die Boxen in das Lager ein- und ausfährt. Dieser ist in das YZ-Shuttel integriert. Es wird davon ausgegangen, dass um Boxen ein- und auszuheben ca. 210 mm überstand der Gabel benötigt wird. Dies ist also der Mindestverfahrweg der Z-Achse

\paragraph{Linearführung}\mbox{}\\
Geführt wird die Gabel mit zwei Führungsschienen von Igus. Diese bieten Optimale Stabilität sowie, in Verbindung mit einem Führungswagen, eine reibungsarme Bewegung. Wichtig ist jedoch, dass der Schwerpunkt der, am Führungswagenbefestigten Last, nicht mehr als die zweifache Wagenlänge über den Wagen hienausgeht. Danach kommt es zu sehr starker Verklemnmung, und ein Betrieb ist nur mehr schwer möglich. Da, bei einer Auslgeroperation der Schwerpunkt sehr weit übersteht, wird eine TS-01 Führungsschinen und -wagen kombination verwendet. Diese wirkt zwar recht überdimnensioniert doch da der Führungswagen so lang ist, kann ein reibungsarmer Betrieb gewährleiste werden. 

\paragraph{Motor}\mbox{}\\
Als Antrieb für die Z-Achse sollen zwei Nema-17 Schrittmotoren verwendet werden. Hier ist es nicht nötig eine closed-loop Steuerung zu verwenden, da bei jedem Hub auch referenziert werden kann. Weiters kann dadurch Kabelschlepkettenplatz gespart werden. 

\paragraph{Spindelauslegung}\mbox{}\\
Die Z-Achse wird mit einer Spindel angetrieben. Dies bietet Vorteile in Positionsgenauigkeit und Kraftübertragung. Jedoch ist es wichtig, die richtige Spindelsteigung auszuwählen, um die Ballance zwischen Geschwindigkeit und Kraft zu halten. Ziel ist es, für eine richtung des Hubs maximal 5 Sekunden zu benötigen. Sie wird über eine Zahnscheibe und Zahnrimen mit dem Motor verbinden.
Berechnet werden kann diese Zeit mit folgenden Ausdruck:

\vspace{5mm}
\noindent\begin{minipage}{\textwidth}
\begin{minipage}[t]{0.5\textwidth}
    \begin{equation*}
        v = \frac{k}{n_{welle}} = \frac{k}{\frac{n_{motor}}{i}}
    \end{equation*}
    \begin{equation*}
        F = \frac{M_{mot} \cdot i \cdot k}{n_{welle}} \cdot 2 \pi f \cdot \eta 
    \end{equation*}
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
    \vspace{-7mm}
    \begin{align*}
        &M_{mot}: \text{Drehmoment} & &\left[\frac{N}{m}\right]\\
        &n_{mot}: \text{Drehzahl} & &\left[\frac{1}{s}\right]\\
        &k: \text{Wellensteigung} & &\left[\frac{mm}{U}\right]\\
        &i: \text{Übersetzungsverhältniss} & &\left[\right]\\
        &\eta: \text{Wirkungsgrad der Gewindeshraube} & &\left[\right]\\
    \end{align*}
\end{minipage}
\end{minipage}

\vspace{5mm}

So wird berechent, dass eine DS10x12 Spindel mit ihren 12 mm Steigung, bei einer Motordrehzahl von 600 U/min (0.42 Nm) und einem Übersetzungsverhältniss von 2:1, ca. 4 Sekunden pro Richtung benötigt und mit einer Kraft von ca. 90 N bewegt wird. \\Dies entspricht unseren Anforderungen und somit wird diese Spindel gewählt. Um sie zu Lagern wird vorne und hinten der Durchmesser der Spindel verringert, sodass diese in Kugellager geführt werden können.

\paragraph{Sensorik}\mbox{}\\
Um auch die Endschlater der Z-Achse, sowie weitere Sensoren einzulesen, wird auch hier ein ASi-Slave montiert.

\subsubsection{Lager}
Das Lager soll die Boxen beeinhalten, und die Möglichkeit zulassen, dass dies von der Gabel ein- und ausgehobenwerden. Weiters muss, die Box in X- und Z-Richtung geführt werden, um Positionsgenauigkeit sicherzustellen, da sonst die Gabel möflicherweise in die Box fährt. Das Lager soll darauf ausgelegt werden, dass Boxen mit den Maßen 50x100x200mm verwendet werden können. Diese Boxen sind nach unten hinn verjüngt und haben oben eine Lippe, an der die Gabel greift.\\
Umgesetzt wird dies mit eine Gerüst aus 40x40-Item-Profilen, welches im nachhienein in den restlichen Rahmen eingesetzt wird. Auf diese werden 20x40-Profile horizontal Aufgeschraubt, auf diesen stehen dann die Boxen. Vorne und hinten wird eine Kunststoffplatte aufgeschraubt welche leicht überstehen und somit die Box in Z-Richtung positioniert. Zwischen den Boxen wird ein Trennsteg eingebaut, welcher die Boxen in X-Richtung Positioniert sowie den richtigen Abstand zwischen den Boxen einzuhalten.

\subsubsection{Querförderer}
Da es dem Portalroboter nicht möglich ist, die Boxen dierekt auf das Förderband zu legen, muss hier noch ein System eingebunen werden, welches dies erledigt. Da die Boxen beim ein- und auslagern den gleichen Weg zurücklegen, muss dieser Querförderer, die Box sowohl auf das Förderband, sowie vom Förderband herunterbewegen kann. 
Zu diesem Zweck wir eine weitere, der Gabel ähnlichen Konstruktion montiert, welche auf einem 20x40-V-Slot-Profil verläuft. Die Box wird dann hin- und her geschoben, um vom Lager auf das Fördeband umzuladen. Dadurch ist es noch möglich, dass die Gabel der Z-Achse die Box in der Nulstellung ein- und aushebt.


\subsubsection{Fertigung der Einzelteile}

\paragraph{Lasern}\mbox{}\\
An der HTL-Mössingerstraße ist es den SchülerInnen möglich einen Lasercutter zur Kunstoffverarbeitung zu verwenden. Um ein gewünstes Teil Ferigen zu können, muss die Kontour dieses als .dwg zur verfügung stehen. Dieses kann dann unter berücksichtigung der Materialstärke aus verschiedenen Farben geschnitten werden.


\paragraph{Fräsen}\mbox{}\\
Um Aluminiumteile zu fertigen steht eine 3-Achsen CNC-Fräse zur Verfügung. In dieser ist es möglich die Teile zu fräsen, die aufgrund ihrer hohen mechanischen Beanspruchung nicht aus Kunststoff gefertigt werden können, aus anderen Materialien herzustellen. Um dies zu bewerkstelligen, muss zuerst der G-Code in Filou-NC16 programmiert werden und kann dann in NC-Easy auf der CNC-Fräse ausgeführt weren. Da der Fräser jedoch einen größeren Durchnesser als der Laser hat, muss, wenn Ecken benötigt werden, eine Aussparung größer dem Durchmesser des Fräsers, eingeplant werden.\\
Als Aluminiumlegierung wird hier die Legierung EN-AW 5754 (AlMg3) verwendet. Diese Legierung aus Aluminium und Magnesium eignet sich sehr gut zum Fräßen und ist in der Lage, die mechanischen Beanspruchungen auszuhalten.

\paragraph{Aluminium-Extrusionen schneiden}\mbox{}\\
Um Aluminiumextrusionen abzulängen wird eine eigens dafür ausgelegte Kreissäge verwendet. In dieser ist es möglich einen Anschlag für eine bestimmte länge einzustellen und dann abzuschneiden. Dadurch ist es möglich in kurzer Zeit viele verschiedene längen zuzuschneiden. 

\paragraph{Umlenkrollen}\mbox{}\\
Die Umlenkrollen sind jeweils am Ende der X- und Y-Achsen angebracht. Dadurch dass diese der gesamten Spannkraft ausgesetzt. Dies erfordert spezielle Anforderungen an die Aufhängen als auch an die Umlenkrolle selbst. Diese soll primär eine 180° Wende des Zahnriemens ermöglichen, sowie sekundär eine Führung für den Riemen bieten. 
Umgesetzt wird diese Anforderungen, durch Fertigung von vier Aluminium-Drehteilen in welche Kugellager eingepresst werden.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{AT5x16-Umlenkung.png}
    \caption{Bauteilzeichnung Umlenkrolle}
    \label{UmlenkrolleBTZ}
\end{figure}

Die Fertigung dieses Teils nach Abb. \ref{UmlenkrolleBTZ} lässt sich in folgende Teilschritte unterteilen:
\begin{itemize}
    \setlength\itemsep{-1mm} 
    \item Zuerst die Frontfläche Plandrehen (Drehzahl: 900 U/min)
    \item Ungefär 30mm Länge auf das Aussenmaß von 36 mm Plandrehen
    \item Mit 9.8mm Bohrer das mittlere Loch vorbohren (540 U/min)
    \item Mit 10mm Reibeisen und viel Öl das Loch auf eine genaue Passung bringen (260 U/min)
    \item Die Position relativ zum Backenfutter markieren, um beim Neu-Einspannen Rundlaufgenauigkeit zu gewährleisten
    \item Zylinder bei ca. 26 mm Abstechen (540 U/min)
    \item Umspannen und auf Maß Plandrehen (900 U/min)
    \item Die Aussparung für die Lager mit Eckdrehmeißel beginnen, jedoch nach innen hin nur 6.8 mm
    \item Bei ca. 17 mm Lochdurchmesser den tatsächlichen Durchmesser mit der Digitalanzeige vergleichen und gegebenenfalls korrigieren
    \item Bei 21.5 mm den Oberschlitten die restlichen 0.2 mm zustellen und die gesamte Tiefe Plandrehen
    \item Den Lochdurchmesser auf 21.95 erweitern und dann in kleinen Inkrementen zustellen, bis das Lager gerade so nicht passt, um einen Presssitz zu gewährleisten. Dies tritt bei Lagern mit 22 mm Außendurchmesser bei rund 22.04 mm ein.
    \item Da für die Einsparung der Riemenführungsfläche kein Angriffspunkt verfügbar ist, wurde als Halterung ein Dorn nach Abb. \ref{ulr:dorn} gedreht, auf welchen das Drehteil aufgeschraubt wird.
    \item Mit dem Abstechmeißel wird in 2 mm Inkrementen die Zahnriemenauflagefläche herausgedreht, bis auf 30.2 mm, sowie links und rechts den Rand 1 mm extra dick lassen (siehe Abb. \ref{ulr:f1} ). (540 U/min)
    \item Am Schluss wird die Rand Tiefe auf Maß gedreht.
    \item Als letzten Schritt werden links und rechts die zwei Lager eingepresst.
\end{itemize}

    Durch die verhältnismäßig großen Toleranzen bei den Lageraussendurchmessern wird bei 2 der 8 Lagerpassungen zusätztlich Lagerkleber verwendet um eine zuverlässigen Halt zu gewährleisten, da bei diesen die Toleranzen nicht eingehalten wurden. \\
    Nach diesem Vorgang sind die vier umlenkrollen fertig (siehe \ref{ulr:f2}) und können auf einem 8 mm Schaft montiert werden.

    \begin{figure}[H]
        \centering
        \begin{subfigure}{.3\textwidth}
            \centering
            \includegraphics[width=0.9\textwidth]{AT5x16-Umlenkung-Dorn.png}
            \caption{Dorn}
            \label{ulr:dorn}
        \end{subfigure}%
        \begin{subfigure}{.3\textwidth}
            \centering
            \includegraphics[width=0.9\textwidth]{ulr-fertigung.jpg}
            \caption{Fertigung der Lauffläche}
            \label{ulr:f1}
        \end{subfigure}%
        \begin{subfigure}{.3\textwidth}
            \centering
            \includegraphics[width=0.9\textwidth]{Umlenkrollen_fertig.jpg}
            \centering
            \caption{Fertiggestellte \\Umlenkrollen}
            \label{ulr:f2}
        \end{subfigure}
        \caption{Umsetzung der Umlenkrollen}
        \label{ulr}
    \end{figure}

\paragraph{Distanzhülsen}\mbox{}\\
Bei den mesiten V-Wheels werden Distanzhülsen zur Klemmung benötigt. Dies müssen ein sehr spezielles Maß (13.4 mm Länge) haben. Deshalb müssen Hülsen mit einer Länge von 20 mm auf diese Länge heruntergedreht werden. Dies wird mit dem rechten Eckdrehmeißel bei einer Drehzahl von 740 U/min ausgeführt. Da relativ viele solcher Teile benötigt werden, wird beim Einspannen der Drehmeißel selbst als Endstopp verwendet, um ein relativ wiederhohlgenaues Maß zu erhalten sowie eine simple Durchführung zu erlauben. Es wird also der Meißel auf Position gefahren und das Werkstück eingespannt, so, dass es am Drehmeißel ansteht. Nun wird der Drehmeißel zurückgefahren und die Hülse kann einfach durch mehrere Plandrehoperationen, bis der Schlitten ansteht, gekürzt werden. Es muss also weder gemessen, noch die Digitalanzeige verändert werden, um schnell mehrere Teile hintereinander zu fertigen. 

\paragraph{Zahnscheiben}\mbox{}\\
Da die Welle des Motors recht kurz ist, als auch die Motoraufhängung Platz wegnimmt, ist es erfordelich die Zahnscheibe unkonventionell mit dem Motor zu verbinden. Es werden also in der Zahnrimen-Kontaktfläche zwei Löcher gebohrt, angesenkt und mit M4 Gewinde versehen, um dort 2 M4 Wurmschrauben einzuschrauben. Bei der Länge der Wurmschrauben muss darauf geachtet werden, dass sie, im montierten Zustand, sich komplett unter der Oberfläche befindet, um den Zahnriemen nicht zu beschädigen.

\subsubsection{Aufbau}


\newpage
\subsection{Software und Benutzeroberfläche}

\subsubsection{Grundlegendes}
Um dem Endnutzer die möglichkeit zu geben, das AFSS möglichst einfach zu bedienen, sowie die komplexen Logik zu Lagersteuerung auszuführen, bedarf es eines Servers (Backend) und einer graphischen Benutzeroberfläche (GUI oder Frontend). Diese müssen eine Vielzahl an Verschiedenen Funktionen beinhalten.

\subsubsection{Aufbau}
\begin{figure}[h]
    \includegraphics[width=\textwidth]{Software Howl.drawio.png}
    \caption{Gesamtüberblick des Servers}
\end{figure}

Um diesen Anforderungen gerecht zu werden, muss eine Lösung mit sehr hohem grad an Freiheit in der Logik sowie UI gestaltung gewählt werden. Weiters muss es möglich sein, dass zukünftige Schülerinnen und Schüler diesen instandhalten und erweitern. Aus diesen Gründen, sowie den bereits vorhandenen Kentnissen, wird die Programmiersprache 'Python' als Grundlage des Servers verwendet.

\paragraph{Python}\mbox{}\\
Python ist eine vielseitige und hochentwickelte Programmiersprache, die für ihre Einfachheit und Lesbarkeit bekannt ist und sich sowohl für Anfänger als auch für Fortgeschrittene eignet. Sie unterstützt mehrere Programmierphilosophien, darunter objektorientierte und funktionale Programmierung, und wird in Bereichen wie Webentwicklung, Datenanalyse, künstliche Intelligenz und wissenschaftlichem Rechnen häufig eingesetzt. \cite{chatgpt}

\paragraph{Flask}\mbox{}\\
Flask ist ein leichtgewichtiges Web-Framework für Python, das durch seine Einfachheit und Flexibilität hervorsticht und sich ideal für kleinere Anwendungen oder Prototypen eignet. Es folgt einem minimalistischen Ansatz, bietet aber Erweiterungsmöglichkeiten, um komplexere Projekte zu realisieren. \cite{chatgpt}

\paragraph{Python - Virtuelle Umgebung}\mbox{}\\
Dieses Projekt enthält sehr viele externe Bibliotheken. In Python sind diese Bibliotheken mit dem Interpreter verknüpft, da bei Installation diese externen Bibliotheken dierekt beim Interpreter gespeichert werden. So kommt es allerdings dazu, dass wenn das Programm auf einer anderen Maschine ausgeführt wird, diese Bibliotheken nicht vorhanden sind. Um Abhängigkeitskonflikte und Portabilitätsprobleme zu verringern, werden Virtuelle Umgebungen verwendet. Diese enthalten den Interpreter sowie die Bibliotheken und könnten einfach auf eine andere Maschine kopiert werden.\\
Dies ist jedoch bei diesem Projekt nur bei der Entwicklung von nöten, da es bei Fertigsteilung im Docker Container ausgefüht wird.

\subsubsection{Benutzeroberfläche}

Um die Benutzeroberfläche zu realisieren muss eine Weboberflche erstellt werden. Auf dieser werden alle Inhalte angezeigt die für die Benutzung nötig sind. Sie wird vom Server zu verfügung gestellt, sobalt dieser eine http-Anfrage erhält. Um diese mit eigenen Inhalten und Funktionen zu befüllen, muss dies mit HTML geschehen.

\paragraph{HTML}\mbox{}\\
HTML (HyperText Markup Language) ist die Standard-Auszeichnungssprache zur Strukturierung und Darstellung von Inhalten im Web. Sie definiert die grundlegende Struktur einer Webseite mit Elementen wie Überschriften, Absätzen, Links, Bildern und Formularen. \cite{chatgpt}\\

Dadurch, dass sich viele Elemente des UI wiederholen, wie z.B. Navigationsleiste, bietet Falsk die Möglichkeit sog. 'Templates' zu verwenden. Diese können einmal definiert werden und dann an mehreren teilen der Webseite verwendet werden.
Um elemente wie Formularflöchen oder Datenanzeige, einfach mit den benötigten Daten anzuzeigen, gibt die möglichkeit Macros zu erstellen, welche von Flask mit den bestimmten Daten vorgerendert und in das restliche HTML eingefügt werden.
Um HTML, welches grundsätzlich ohne Formatierung auskommt, zu stylen, muss CSS verwendet werden. 

\paragraph{CSS}\mbox{}\\
CSS (Cascading Style Sheets) ist eine Stylesheet-Sprache, die verwendet wird, um das Design und Layout von Webseiten zu gestalten. Sie ermöglicht die Trennung von Inhalt und Darstellung, indem sie Farben, Schriftarten, Abstände und andere visuelle Aspekte definiert.\cite{chatgpt}\\

Da auch Logik in der Webseite verbaut werden muss, muss zusätzlich auch Javascript verwendet werden, da HTML und CSS alleine, noch nicht gut genug mit dem Server Kommunizieren können.

\paragraph{JavaScript}\mbox{}\\
JavaScript (JS) ist eine vielseitige Programmiersprache, die hauptsächlich verwendet wird, um interaktive und dynamische Elemente auf Webseiten zu erstellen. Sie läuft direkt im Browser und ermöglicht Funktionen wie Animationen, Formularvalidierungen und die Kommunikation mit Servern in Echtzeit.\cite{chatgpt}\\

Praktisch geschieht diese Server-Kommunkation immer mithilfe diese Programmblocks:

\begin{lstlisting}[language=JavaScript]
    function sendData(data, callback) {
        var xhr = new XMLHttpRequest();
        var url = "{{url_for('main.add_stock')}}"; //Flask markup, um die richtige url zu erreichen, dies wird vor ausgabe auf der Webseite noch eingesetzt

        xhr.open("POST", url, true);
        xhr.setRequestHeader("Content-Type", "application/json");

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                callback(xhr.responseText)  //die funktion wir aufgerufen
            }
        };
        var jsonData = JSON.stringify(data);
        xhr.send(jsonData);
    }
\end{lstlisting}

Dieser ermöglicht die Übergabe von Daten im JSON format, und einer Funktion, die die zurückgeschickten Daten verarbeitet. In der Praxis wird dieser so aufgerufen:

\begin{lstlisting}[language=JavaScript]
function add_to_db(){
    sendData({"add_stock": {"barcode": barcode, "quantity": quant, "article": article}}, 
    set_gen_stock)
}

function set_gen_stock(req){
    document.getElementById("generated").innerHTML = req
}\end{lstlisting}

Wie im Quellcode ersichtlich, werden Daten aus der Webseite ausgelesen, in JSON konvertiert. Danach werden diese Daten zusammen mit einer Funktion, an 'send\_Data'. Wie bereits erwähnt, gibt der Server dann Daten zurück. In diesm Fall, werden dann Datten aus der DB vorformattiert. Diese werden dann in der zuvor übergebenen Funktion, in der Webseite eingefügt.

\subsubsection{Backend}
Das Backend des Servers ist für die Datenverarbeitung verantwortlich. Es ist wie bereits erwähnt in Python geschrieben und stellt mit dem Flask-Framework die Benutzeroberfläche zur Verfügung. \\
Aufgebaut ist es in mehrere Bereiche. Einerseits die Webanwendung, sowie API (Application-Prgramming-Interface, Schnittstelle zwischen Anwendungen) als auch die Anbindung an die Datenbank sowie Verarbeitung der SPS-Befehle und API zugriff auf dies.

\paragraph{Serverseite der Benutzeroberfläche}\mbox{}\\
In Flask könne 'bleuprints' definiert werden. Dies sind Webseitelemente die einen Bestimmten URL-Vorsatz haben. So werden anfanges 'blueprints' für Hauptfunktionen ('/', also ohne Vorsatz), Datenbankinteraktionen ('/db\_interactions') usw. definiert. Die Funktionen dafür werden dann in jeweils eigenen Dateien geschrieben. Dies ermöglicht eine weit aus bessere Übersicht bei großen Projekten. \\
Eine Funktion, die für die Verarbeitung der Anfragen einer bestimmten URL verantwortlich ist, sieht immer ähnlich aus.

\begin{lstlisting}[language=Python]
    @main.route("/add_stock", methods=["GET", "POST"])
    def add_stock():
        if request.method == "POST":
            if request.data:
                req = request.get_json()

                if "add_stock" in req.keys():
                    dt = req["add_stock"]
                    new = Stock(
                        container=db.session.query(Container)
                        .filter_by(barcode=dt["barcode"])
                        .first()
                        .id,
                        article=dt["article"],
                        quantity=dt["quantity"],
                    )
                    db.session.add(new)
                    db.session.commit()
                    return "Sucsess"

        return render_template("add_stock.html")
\end{lstlisting}  

Anfangs wird mit einem Decorator (@main.route(...)) die gewünschte URL, sowie unterstützte http-Requests definiert. Decoratoren verändern oder erweitern die Eigenschaften von Funktionen. In diesem Fall wird in der Funktion (def ...()) definiert was geschieht, wenn ein erlaubter Request an der URL 'add\_stock' eintrifft. Dieser Funktionsname kann auch in den Flask-Vorlagen verwendet werden um URLs dynamisch zu vergeben.\\
Weiters wird sortiert um welche art von Art von Anfrage es sich handelt. Bei GET-Anfragen wird typischerweise einfach nur das HTML der Webseite zurückgegeben. Bei POST-Anfragen werden zuerst die Daten dieser Anfrage eytrahiert und dann entschieden was damit gemacht werden soll. In diesem Fall wird, wenn des richtige Schlüsselwort in der Anfrage enthalten ist, ein Datenbankeintrag, mit den Daten aus dem Request, hinzugefügt. Schlussendlich wird ein Wert zurückgegeben, entweder ein HTML-Statuscode, vorgerendertes HTML oder, wie in diesem Fall, ein Text.

\subsubsection{APIs}

\paragraph{SPS - Verbindung}\mbox{}\\
Die Daten für die SPS werden in einem Ähnlichen vefahren zu verfügung gestellt. Nun schickt nicht die Benutzeroberfläche oder der Browser eine Anfrage an das Backend, sondern die SPS. Der Programmblock zur Verarbeitung dieser Anfrage sieht folgenderaßen aus:

\begin{lstlisting}[language=Python]
@api.route("/afss", methods=["GET", "POST"])
def afss():   
    request_data = {...} #aus platzgruenden verkuerzt
    if request.method == "POST":
        ... # Abfrage ob der Sender eine Siemens SPS ist
        if "next_bmos" in req.keys():
            if req["next_bmos"] == "":
                return "400"

            if is_SPS:
                return convert_instruction_for_PLC(afss_stack.get_current_bmos(int(req["next_bmos"])))

            return jsonify(afss_stack.get_current_bmos(
                int(req["next_bmos"])))

        if "inst_acknowledge" in req.keys():
            if is_SPS:
                ack = afss_stack.inst_acknowledge(
                    int(req["inst_acknowledge"]))
                if ack == "204":
                    return ack
                return convert_instruction_for_PLC(ack)
\end{lstlisting}  

Die Funktion dieses Codeblocks besteht darin, herrauszufiltern, ob eine Anfrage einer Siemens-SPS eintrifft und dann dementsprechend Daten zurückzugeben.
Wenn eine Anfrage mit dem Schlüssel 'next\_bmos' (next-box-moveing-operation) empfangen wird, wird diese dem sog. 'stack' weitergegeben, welcher diese dann verarbeitet (dies wird im Anschluss näher behandelt). Sollte diese von einer SPS kommen, werden die Zurückgeschicten Daten vorher noch so bearbeitet, dass diese von der SPS möglichst gut übersetzt werden können.
Sollte die SPS ein 'inst\_acknowledge' sowie die dementsprechenden Daten, wird im 'Stack' vermerkt dass die dementsprechende Operation bei der SPS angekommen ist.

Weiters bietet Simens auch die Möglichkeit über den Webserver der CPU auf diese zuzugreifen. Dies geschieht über das JSON-RPC Protokoll \cite{ws_s7}. Aus Testzwecken ist des durchaus nützlcih auh dierekten Zugriff auf die CPU zu haben, wenngleich es für den Normalbetrieb nicht zwingend benötigt wird. Um eine möglichst einfache bedienung zu Ermöglichen wird ein Objekt angelegt, um JSON-RPC Befehle auszuführen.

\begin{itemize}
    \item Login: Um die SPS zugreifen zu können muss erst ein Login geschehen. Hierbei werden Benutzername und Passwort benötigt, die zuerst in der SPS festgelegt wurden. Dieser führt bei Erfolg zu einem 'Session-Token', welches bei jeder folgenden Kommunikation zur Authentifizierung mitgeschickt werden muss.
    \item Daten Lesen: Die Methode 'PlcProgram.Read' gibt den Wert einer gegebenen Variable zurück.
    \item Daten Schreiben: Mit 'PlcProgram.Write' kan der Wert einer oder mehrere Variablen geändert werden.
\end{itemize}

Diese Objekt kann dann einfach in einen Anderen Programmteil importiert werden, und dort dann die Verbindung zu einer SPS herstellen. Theoretsich könnt man auch mehrere dieser Objekte anlegen, um Zugriff mehreren Steuerungen umzusetzen.

\subsubsection{Lageralgorithmus für SPS}\mbox{}\\

\begin{wrapfigure}{R}{0.6\textwidth}
    \centering
    \includegraphics[width=0.52\textwidth]{stack.png}
    \caption{Diagramm der BMOS bereitstellung}
\end{wrapfigure}

Die Auftrage sind im Einkaufswagen o.ä. im Format 'Location -\> Location' hinterlegt. Um dies in eine Opeation zu zerlegen die die SPS versteht, wird eine Box-Moveing-Operation erstellt. Diese enthält alle Teilschritte, wie Schlittenposition oder Fördebandstracke, um eine Box von Position A zu Position B zu bringen. 
Die BMO wird dann in die einzelnen verwendeten Module, Förderband oder Lager, aufgeteilt und dann dem 'stack' zugeführt. Diese Instruktion enthält Daten wie:
\begin{itemize}
    \item 'instruction\_id': Eine fortlaufende Nummer um jede Anweisung zu identifizieren
    \item 'order\_id': Zusammenhängende Anweisungen, bzw. Anweisungen für die gleiche Box, haben eine gleiche Nummer
    \item 'relation': eine Liste mit 'instruction\_id's', welch vor dieser Anweisung erfüllt sein müssen
\end{itemize} 

Bei Auswahl der zu schickenden Anweisung, wird zuerst die aktuell von der SPS gemachte Anweisung vermerkt, danach weird in allen Modulen des 'stacks' nachgeschaut, welche Anweisungen jetzt ausgeführt werden können. Zu diesem Zweck wird die 'relation' einer Anweisung mit den bereits gemachten Anweisungen verglichen, wenn bereits alle relevanten Anweisungen gemacht wurden, wird der Auftrag in 'to\_send' vermerkt. Schlussendlich wird einer der in 'to\_send' vermerkten Aufträge für die SPS übersetzt und an diese geschickt. 
Wenn die SPS den Auftrag erhalten hat, schickt sie ein 'acknowledge' mit der erhaltenen ID zurück. Der Auftrag wird dann aus den 'instructions\_to\_send' gelöscht und entweder wird einfach der nächste Auftrag in 'to\_send' geschickt oder der 'BMOS' Algorithmus wird erneut durchlaufen.


\subsubsection{Datenbanken}

Als Datenbanksystem wird aufgrund des guten Supports MySQL gewählt. Dies ist ein relationales Datenbankmanagementsystem welches in einem Docker-Container aufgesetzt wird. In diesem werden alle Daten gespeichert, die zur Auswahl sowie zur Ausliferung von Teilen nötig sind.

\begin{figure}[h]
    \includegraphics[width=0.6\textwidth]{DB-Schema.png}
    \centering
    \caption{Datenbankschema des AFSS}
    \label{DB-Scema}
\end{figure}

Wie in \ref{DB-Scema} ersichtlich, beinhalt diese Datenbank fünf Tabellen. Diese hohe Komplexität resultiert daraus, dass diese Struktur eine 100\%ige Flexibilität in der Ablage von Bauteilen in einem überliegendem System bietet.

Die Erste Tabelle beschreibt ein einziges theoretisches Bauteil. Dieses hat einen Namen, Gewicht, Beschreibung und Kategorien zur Filterung. Unter der Spalte 'picture' wird ein Dateiname gespeichert, der zu einem Bild zeigt, dass das Produkt abbildet.
Die zweite beschreibt einen Container. Im Lagersystem entspricht dieser einer Box. Diese kann mehrere `stocks' beinhalten, sowie durch einen Barcode identifiziert werden. Weiters muss jeder Container immer eine aktuelle Position (`current\_location') besitzen, an der die Box gerade ist. Im ausgelagerten (und noch nicht eingelagerten) Zustand ist diese `location' Position 0. Das Ziel der Box wird in `target\_location' gespeichert. Stimmt die aktuelle mit der Zielposition überein, so ist die Box an ihrem Ziel angelangt. Die Kategorie `size' beschreibt die Größe eines Containers und lässt somit theoretisch zu, dass in Zukunft auch unterschiedlich große Boxen zuverlässig in die richtigen Lagerplätze eingelagert werden. `priority' wird nicht verwendet.

Container und Artikel werden im sog. 'stock' verheiratet. Dieser kann als bauteilhaufen in einer Box verstanden werden. Es können also auch mehrere 'stocks' mit dem selben Container geben, dies würde mehreren verschiedenen Bauteilen in einem einzigen Copntainer entsprechen. Auch ist es möglich mehrere Container mit den selben 'stocks' abzubilden, welches ener aufteilung von Abuteilen auf mehrere Container entspräche.

Die Positionen der Container werden in Standorte ('locations') abgebildet. Diese entsprechen den Lagerplätzen. Sie sind einer darüberliegenden 'area' zugeordnet, welche einerseits einen Lagerschrank, aber weiters auch Module wie Vereinzelungsanalgen, abbilden kann. Standorte verfüghen weiters über eine Position welche in X, Y und Z-Richtung beschreibt, wo sich ein Standort im Referenzsystem des Lagers befindet. Auch die größe des Lagerplatzes wird abgebildet, um sicherzustellen, dass auf jeden fall nur die richtige Größe an Box eingelagert wird.


\subsubsection{Docker}

    \begin{wrapfigure}{r}{0.3\textwidth} % 'r' for right, 'l' for left
        \vspace{-20px}
        \includegraphics[width=0.3\textwidth]{docker-logo-011.png} % Replace with your image file
        \caption{Docker-Logo: \cite{docker_logo}}
    \end{wrapfigure}

    Docker ist eine Umgebung, in der Softwareprojekte isoliert werden können. Da besonders auch bei Projekten mit großem Python anteil, viele Pakete mit verschiedenen Versoinen benötigt werden, ist es sehr hilfreich diese zu bündeln. \\
    Umgesetzt wird dies mithilfe von Containern welche einen gesamten Programmteil als alleinstehende Einheit enthält. Diese werden über ein 'Dockerfile' configuriert, welches sich im selben Ordner wie die Python-Anwendung befindet. In diesem werden Parameter wie die Python-Version und die benötigten pip-Pakete sowie den Programmeinstiegspunkt angegeben. \\ 
    Ein zweier Docker Conteianer wird mit einem MySQL-Image erstellt, dort wird die Datenbank aufgesetzt. \\
    Um diese Zwei Container miteinander Kommunizieren zu lasen, ist es ntig ein sog. docker-compose.yml File zu erstellen. Dies enthält alle Informationen über verwendete container, deren Ports, sowie Speicher für Dateien (Volumes). Bei Testbetrieb wird der Datenbankcontainer aleinstehend bestrieben und mit einem anderen Port, keine Zugriffsprobleme zu generieren. In Produktion wird dann derselbe Container in den Containerverband übertragen und dort mit einem anderen Port weiterverwendet. \\
    Erstellt wird dieser Containerverband mit den Consolenbefehlt der auf das docker-compose File zugreift. 
    \begin{lstlisting}[language=bash]
        docker build docker-compose.yml\end{lstlisting}
    Dann werden auch alle Logs in der Kommandozeile ausgegeben sowie 


\subsubsection{Artikelsuche}
\paragraph{TF-IDF und Rust Implementierung} \hspace{0pt} \\
Der TF-IDF (Term Frequency-Inverse Document Frequency) Algorithmus, ist ein Weg um wichtige wörter aus Dokumenten zu extrahieren. Er wird verwendet um beispielsweise in Suchmaschienen, eine Suchanfrage mit Webpagecontent abzugleichen, und die am besten mit der Suchanfrage übereinsteimmenden Dokumente zu sortieren. \\
Im Fall dieser Anwendung werden die Daten aus der Artikeldatenbank als 'Dokumente'  angesehen und die Suchanfrage aus dem Suchfeld wird dafür verwendet um die am besten passenden Artikel zu finden.
\\
Durch den Relativ hohen Rechenaufwand bei dieser Suchoperation wird dieser in der Programmiersprache Rust implementert. Die Implementierung in Rust ist im vergleich zu Python schon bei relativ kleinen Datenmenge bis zu 5-mal schneller.

\subparagraph{Rust}\mbox{}\\
Rust ist eine sehr effiziente und schnelle Programmiersprache die in den späten 2000er und frühen 2010ern bei Mozilla und der Open-Source-Community entwickelt. Sie unterstützt unter anderem mehr Typensicherheit und verhindert viele Programmierfehler.\cite{chatgpt}

Die Funktion dieses Algorithmus ist in drei unterteile Unterteilt.

\begin{enumerate}
    \item Term Frequenz \\
    Die Termfrequenz gibt an, wie oft ein angegebenes Wort in einem Dokument vorhanen ist. Dies wird durch die Folgende Funktion kalkuliert.
    
    \begin{lstlisting}[language=Rust]
fn term_frequency(document: &str, term: &str) -> f64 {
    // Store the lowercase document as a String to ensure it lives long enough
    let lower_document = document.to_lowercase(); 

    // Split the document into words
    let normalize_document: Vec<&str> = lower_document.split_whitespace().collect();
    // Make sure the searchterm is lowercase
    let normalize_term = term.to_lowercase();

    // Count occurrences of the term in the document
    let count = normalize_document
        .iter()
        .filter(|&&word| word == normalize_term) // Compare each word with the term
        .count();

    // Calculate the term frequency as occurrences / total number of words
    let total_words = normalize_document.len();
    if total_words == 0 {
        0.0 // Avoid division by zero if the document is empty
    } else {
        count as f64 / total_words as f64
    }
}\end{lstlisting}

    Mithilfe dieser wird eine Liste aller Wörter und der Vorkommenshäufigkeit dieser erstellt.

    \item Die zweite Komponente ist dann die Inverse Dokument Frequenz. Diese gewichtet, die Anzahl der Dokumente in dem das gesuchte Wort enthalten ist relativ zur Gesamtdokumentanzahl vorkommt. Häufig vorkommende Worte wie z.B. 'und' werden hierbei weniger gewichtet als einzigartige Wörter.

\begin{lstlisting}[language=Rust]
fn inverse_document_frequency(term: &str, all_documents: &Vec<String>) -> f64 {
    let mut num_documents_with_this_term = 0;

    // Iterate over all documents to check if they contain the term
    for doc in all_documents {
        // Normalize both term and document by converting them to lowercase
        let lower_doc = doc.to_lowercase();
        let normalized_doc: Vec<&str> = lower_doc.split_whitespace().collect();

        // Check if the term exists in the document
        if normalized_doc.contains(&term.to_lowercase().as_str()) {
            num_documents_with_this_term += 1;
        }
    }

    // Calculate IDF
    if num_documents_with_this_term > 0 {
        // Apply the IDF formula: 1 + log(total_documents / documents_with_term)
        1.0 + ((all_documents.len() as f64) / (num_documents_with_this_term as f64)).ln()
    } else {
        // If the term is not found in any document, return 1.0
        1.0
    }
}
\end{lstlisting}

    \item Nun liegt Liste davon vor, wie oft ein Wort in den Suchdaten vorkommt, als auch, wie oft ein Suchbegriff in einem bestimmten Dokument ist. \\ Als nächsten Schritt werden diese beiden Werte für jeden Suchbegriff miteinander multipliziert und ergeben somit einen Vektor der die Suchwörter in Relation zu jedem einzelnen Dokument stellt.
    \item Als letzten Schritt wird der zuvor errechnete Dokumentenvektor (der IDF jedes Suchterms in jedem Dokument) mit dem Suchvektor verglichen. Die geschieht mit der sog. Kosinus-Ähnlichkeit.
    \begin{lstlisting}[language=Rust]
fn cos_similarity(query_p: Vec<f64>, document_p: Vec<f64>) -> f64 {
    // Ensure that both vectors have the same length
    if query_p.len() != document_p.len() {
        return -1.0;
    }

    let mut dot_product = 0.0;
    let mut abs_doc_squared = 0.0;
    let mut abs_query_squared = 0.0;

    // Calculate the dot product and the magnitudes (squared)
    for i in 0..query_p.len() {
        dot_product += query_p[i] * document_p[i];
        abs_doc_squared += document_p[i].powi(2); // document_p[x] ** 2
        abs_query_squared += query_p[i].powi(2); // query_p[x] ** 2
    }

    // Calculate the magnitudes
    let abs_doc = abs_doc_squared.sqrt();
    let abs_query = abs_query_squared.sqrt();

    // Handle division by zero in case of zero vectors
    if abs_doc == 0.0 || abs_query == 0.0 {
        return 0.0;
    }

    // Return the cosine similarity
    return dot_product / (abs_doc * abs_query);
}\end{lstlisting}
    Nach der Berechnung dieser für jedes Dokument werden alle Dokumente sortiert und ja nach anforderung die benötigte Anzahl ausgegeben.
\end{enumerate}


\subparagraph{Artikelsuche nach Kategorien}\mbox{}\\
Um auche einen simpleren weg der Artikelfindung zur verfügung zu stellen, wird ausserdem die Möglichkeit implementiert, Artikel anhand von Attributen zu suchen. Zu diesem Zweck werden schon bei der Artikelerstellung Attribute für die Einträge 'Gruppen' und 'Kategorien' vergeben. In 'Gruppen' wird eine art Pfad angelegt, der die Suche eingrenzt. Beispielsweise würde so ein Eintrag folgende Daten Einthalten: ["Item", "Verbindungssatz"] enthalten. So kann bei der Artikelsuche zuerst die Überkategorie "Item" und dann die Unterkategorie "Verbindungssatz" aus mehreren verschiedenen ausgewählt werden. Um Bauteile weiter zu unterschieden, da es z.B. viele verschiedene Widerstände gibt, weren unter 'Kategorien' einzelheiten zum Produkt, wie Wert, Farbe o. ä. gespeichert.\\ 
Diese Informationen werden auch vom TF-IDF verwendet, dienen aber spezieller dazu, möglichst sicher das gewünschte Bauteil in einem Durchcklickmenue zu finden.



